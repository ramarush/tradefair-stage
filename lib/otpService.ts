import { PrismaClient } from '@prisma/client';
import * as speakeasy from 'speakeasy';

const prisma = new PrismaClient();

export class OTPService {
  private static instance: OTPService;

  private constructor() {}

  public static getInstance(): OTPService {
    if (!OTPService.instance) {
      OTPService.instance = new OTPService();
    }
    return OTPService.instance;
  }

  /**
   * Get TOTP secret for a user (UUID4 is auto-generated by database)
   */
  async getTOTPSecret(email: string): Promise<{ success: boolean; secret?: string; error?: string }> {
    try {
      // Get user's TOTP secret (UUID4 auto-generated by database)
      const user = await prisma.user.findUnique({
        where: { email },
        select: { totpSecret: true }
      });

      if (!user) {
        return { success: false, error: 'User not found' };
      }

      if (!user.totpSecret) {
        return { success: false, error: 'No TOTP secret found for user' };
      }

      return { success: true, secret: user.totpSecret };
    } catch (error) {
      console.error('Error getting TOTP secret:', error);
      return { success: false, error: 'Failed to get TOTP secret' };
    }
  }

  /**
   * Generate TOTP code for a user
   */
  async generateTOTP(email: string): Promise<{ success: boolean; otp?: string; error?: string }> {
    try {
      const secretResult = await this.getTOTPSecret(email);
      if (!secretResult.success || !secretResult.secret) {
        return { success: false, error: secretResult.error };
      }

      // Generate TOTP with 10-minute window (600 seconds) using UUID4 as secret
      const token = speakeasy.totp({
        secret: secretResult.secret,
        encoding: 'ascii', // UUID4 is ASCII, not base32
        step: 600, // 10 minutes in seconds
        digits: 6
      });

      return { success: true, otp: token };
    } catch (error) {
      console.error('Error generating TOTP:', error);
      return { success: false, error: 'Failed to generate OTP' };
    }
  }

  /**
   * Verify TOTP code for a user
   */
  async verifyTOTP(email: string, otp: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Get user's TOTP secret
      const user = await prisma.user.findUnique({
        where: { email },
        select: { totpSecret: true }
      });

      if (!user || !user.totpSecret) {
        return { success: false, error: 'No TOTP secret found for user' };
      }

      // Verify TOTP with 10-minute window and allow for some time drift
      const verified = speakeasy.totp.verify({
        secret: user.totpSecret,
        encoding: 'ascii', // UUID4 is ASCII, not base32
        token: otp,
        step: 600, // 10 minutes in seconds
        window: 1 // Allow 1 step before/after current time (total 30 minute window)
      });

      if (!verified) {
        return { success: false, error: 'Invalid or expired OTP' };
      }

      return { success: true };
    } catch (error) {
      console.error('Error verifying TOTP:', error);
      return { success: false, error: 'Failed to verify OTP' };
    }
  }

  /**
   * Generate a 6-digit OTP (legacy method for compatibility)
   */
  generateOTP(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }

  /**
   * Store OTP (legacy method - now uses TOTP)
   */
  async storeOTP(email: string, otp: string, expirationMinutes: number = 10): Promise<{ success: boolean; error?: string }> {
    // This method is now a wrapper around TOTP generation
    const result = await this.generateTOTP(email);
    return { success: result.success, error: result.error };
  }

  /**
   * Verify OTP (legacy method - now uses TOTP)
   */
  async verifyOTP(email: string, otp: string): Promise<{ success: boolean; error?: string }> {
    return this.verifyTOTP(email, otp);
  }

  /**
   * Check if email has a pending OTP (always returns false for TOTP since it's time-based)
   */
  async hasPendingOTP(email: string): Promise<boolean> {
    // For TOTP, we don't need to check for pending OTPs since they're time-based
    // We can allow generating new OTPs anytime
    return false;
  }

  /**
   * Clean up expired OTPs (not needed for TOTP)
   */
  async cleanupExpiredOTPs(): Promise<void> {
    // Not needed for TOTP since they're time-based
    return;
  }

  /**
   * Clear TOTP secret for a user (useful for testing or resetting)
   */
  async clearTOTPSecret(email: string): Promise<{ success: boolean; error?: string }> {
    try {
      await prisma.user.update({
        where: { email },
        data: { totpSecret: null }
      });
      return { success: true };
    } catch (error) {
      console.error('Error clearing TOTP secret:', error);
      return { success: false, error: 'Failed to clear TOTP secret' };
    }
  }
}

// Export singleton instance
export const otpService = OTPService.getInstance();